<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SHAD: Scalable High-performance Algorithms and Data-structures: shad::Vector&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SHAD: Scalable High-performance Algorithms and Data-structures
   &#160;<span id="projectnumber">0.0.1 (heads/auto-doxygen-0-g36d621d-dirty)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceshad.html">shad</a></li><li class="navelem"><a class="el" href="classshad_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classshad_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">shad::Vector&lt; T, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">Vector</a> data Structure.  
 <a href="classshad_1_1Vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8h_source.html">shad/data_structures/vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for shad::Vector&lt; T, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classshad_1_1Vector__inherit__graph.svg" width="198" height="128"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for shad::Vector&lt; T, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classshad_1_1Vector__coll__graph.svg" width="198" height="128"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad950d846edeeed7cc4a9163f9f679624"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ad950d846edeeed7cc4a9163f9f679624">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:ad950d846edeeed7cc4a9163f9f679624"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the allocator.  <a href="#ad950d846edeeed7cc4a9163f9f679624">More...</a><br/></td></tr>
<tr class="separator:ad950d846edeeed7cc4a9163f9f679624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb97b89826617473f44b4bb1dd3308ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> = T</td></tr>
<tr class="memdesc:adb97b89826617473f44b4bb1dd3308ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the elements stored in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#adb97b89826617473f44b4bb1dd3308ba">More...</a><br/></td></tr>
<tr class="separator:adb97b89826617473f44b4bb1dd3308ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e5348988a063d58ed55c76fc94cec1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a46e5348988a063d58ed55c76fc94cec1">difference_type</a> = typename allocator_type::difference_type</td></tr>
<tr class="memdesc:a46e5348988a063d58ed55c76fc94cec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type used the difference between iterators.  <a href="#a46e5348988a063d58ed55c76fc94cec1">More...</a><br/></td></tr>
<tr class="separator:a46e5348988a063d58ed55c76fc94cec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c97f4eb87d738cb4de97e5b3587c397"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> = typename allocator_type::size_type</td></tr>
<tr class="memdesc:a1c97f4eb87d738cb4de97e5b3587c397"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integral type that can represent any non-negative value of difference_type.  <a href="#a1c97f4eb87d738cb4de97e5b3587c397">More...</a><br/></td></tr>
<tr class="separator:a1c97f4eb87d738cb4de97e5b3587c397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa71fd41daa1548f8436bc54ef507976"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a> = Iterator&lt; T &gt;</td></tr>
<tr class="memdesc:aaa71fd41daa1548f8436bc54ef507976"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator to <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba" title="The type of the elements stored in the shad::Vector. ">shad::Vector::value_type</a>.  <a href="#aaa71fd41daa1548f8436bc54ef507976">More...</a><br/></td></tr>
<tr class="separator:aaa71fd41daa1548f8436bc54ef507976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab677e6f62431a450c856e7ffe44efbc6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ab677e6f62431a450c856e7ffe44efbc6">const_iterator</a> = Iterator&lt; const T &gt;</td></tr>
<tr class="memdesc:ab677e6f62431a450c856e7ffe44efbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator to const <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba" title="The type of the elements stored in the shad::Vector. ">shad::Vector::value_type</a>.  <a href="#ab677e6f62431a450c856e7ffe44efbc6">More...</a><br/></td></tr>
<tr class="separator:ab677e6f62431a450c856e7ffe44efbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71193856f7dddb5e9fe0128fe5d12448"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a> = typename <a class="el" href="classshad_1_1AbstractDataStructure.html">AbstractDataStructure</a>&lt; <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;&gt;::<a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a></td></tr>
<tr class="memdesc:a71193856f7dddb5e9fe0128fe5d12448"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the unique identifier for the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">Vector</a>.  <a href="#a71193856f7dddb5e9fe0128fe5d12448">More...</a><br/></td></tr>
<tr class="separator:a71193856f7dddb5e9fe0128fe5d12448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classshad_1_1AbstractDataStructure"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classshad_1_1AbstractDataStructure')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classshad_1_1AbstractDataStructure.html">shad::AbstractDataStructure&lt; Vector&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memitem:a8772079d2686692828cfbf342cc2b594 inherit pub_types_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#a8772079d2686692828cfbf342cc2b594">ObjectID</a> = <a class="el" href="classshad_1_1ObjectIdentifier.html">ObjectIdentifier</a>&lt; <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt; &gt;</td></tr>
<tr class="memdesc:a8772079d2686692828cfbf342cc2b594 inherit pub_types_classshad_1_1AbstractDataStructure"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global Object Identifier.  <a href="#a8772079d2686692828cfbf342cc2b594">More...</a><br/></td></tr>
<tr class="separator:a8772079d2686692828cfbf342cc2b594 inherit pub_types_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb29450966955c546d40421ce46316f inherit pub_types_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#a8bb29450966955c546d40421ce46316f">SharedPtr</a> = std::shared_ptr&lt; <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt; &gt;</td></tr>
<tr class="memdesc:a8bb29450966955c546d40421ce46316f inherit pub_types_classshad_1_1AbstractDataStructure"><td class="mdescLeft">&#160;</td><td class="mdescRight">SharedPtr to DataStructure.  <a href="#a8bb29450966955c546d40421ce46316f">More...</a><br/></td></tr>
<tr class="separator:a8bb29450966955c546d40421ce46316f inherit pub_types_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1624c9ed8f177f50071cdeff7ccb3c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a1624c9ed8f177f50071cdeff7ccb3c03">GetGlobalID</a> () const </td></tr>
<tr class="memdesc:a1624c9ed8f177f50071cdeff7ccb3c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataStructure identifier getter.  <a href="#a1624c9ed8f177f50071cdeff7ccb3c03">More...</a><br/></td></tr>
<tr class="separator:a1624c9ed8f177f50071cdeff7ccb3c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3505368cf8e3cef009b8d1f894a8e97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#af3505368cf8e3cef009b8d1f894a8e97">~Vector</a> ()</td></tr>
<tr class="memdesc:af3505368cf8e3cef009b8d1f894a8e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af3505368cf8e3cef009b8d1f894a8e97">More...</a><br/></td></tr>
<tr class="separator:af3505368cf8e3cef009b8d1f894a8e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34d718c025cee060735b3bced4cf38b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ac34d718c025cee060735b3bced4cf38b">BufferEntryInsert</a> (const std::tuple&lt; <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>, <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &gt; entry)</td></tr>
<tr class="separator:ac34d718c025cee060735b3bced4cf38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e4b374c0cdc673273716d08c83161"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a6b3e4b374c0cdc673273716d08c83161"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a6b3e4b374c0cdc673273716d08c83161">InsertAt</a> (<a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, IteratorType begin, IteratorType end)</td></tr>
<tr class="separator:a6b3e4b374c0cdc673273716d08c83161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feab819cbb5f85388a42e9548983479"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a0feab819cbb5f85388a42e9548983479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a0feab819cbb5f85388a42e9548983479">AsyncInsertAt</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, IteratorType begin, IteratorType end)</td></tr>
<tr class="separator:a0feab819cbb5f85388a42e9548983479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f503abd217734deaa5baafb8142ab45"><td class="memTemplParams" colspan="2">template&lt;typename ApplyFunT , typename... Args&gt; </td></tr>
<tr class="memitem:a5f503abd217734deaa5baafb8142ab45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a5f503abd217734deaa5baafb8142ab45">Apply</a> (const <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, ApplyFunT &amp;&amp;function, Args &amp;...args)</td></tr>
<tr class="separator:a5f503abd217734deaa5baafb8142ab45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e9f5dd9a9f35d59df36c8e7bb334c2"><td class="memTemplParams" colspan="2">template&lt;typename ApplyFunT , typename... Args&gt; </td></tr>
<tr class="memitem:a81e9f5dd9a9f35d59df36c8e7bb334c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a81e9f5dd9a9f35d59df36c8e7bb334c2">AsyncApply</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, const <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, ApplyFunT &amp;&amp;function, Args &amp;...args)</td></tr>
<tr class="separator:a81e9f5dd9a9f35d59df36c8e7bb334c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:acc82ec6a8baf31c7b33cfde87309fffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#acc82ec6a8baf31c7b33cfde87309fffe">Size</a> () const noexcept</td></tr>
<tr class="memdesc:acc82ec6a8baf31c7b33cfde87309fffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of element stored in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#acc82ec6a8baf31c7b33cfde87309fffe">More...</a><br/></td></tr>
<tr class="separator:acc82ec6a8baf31c7b33cfde87309fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3456999188ff7f9e43ca8d1e7d4bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#abf3456999188ff7f9e43ca8d1e7d4bff">MaxSize</a> () const noexcept</td></tr>
<tr class="memdesc:abf3456999188ff7f9e43ca8d1e7d4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements that <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> can hold.  <a href="#abf3456999188ff7f9e43ca8d1e7d4bff">More...</a><br/></td></tr>
<tr class="separator:abf3456999188ff7f9e43ca8d1e7d4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba3d706d24f0b871dc05423692ac592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#acba3d706d24f0b871dc05423692ac592">Capacity</a> () const noexcept</td></tr>
<tr class="memdesc:acba3d706d24f0b871dc05423692ac592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the allocated storage capacity.  <a href="#acba3d706d24f0b871dc05423692ac592">More...</a><br/></td></tr>
<tr class="separator:acba3d706d24f0b871dc05423692ac592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3eb293e1a9f7b64ca1a77e40caef993"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ae3eb293e1a9f7b64ca1a77e40caef993">Empty</a> () const noexcept</td></tr>
<tr class="memdesc:ae3eb293e1a9f7b64ca1a77e40caef993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> is empty.  <a href="#ae3eb293e1a9f7b64ca1a77e40caef993">More...</a><br/></td></tr>
<tr class="separator:ae3eb293e1a9f7b64ca1a77e40caef993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba27b70744d34815776697084245777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#aaba27b70744d34815776697084245777">Reserve</a> (<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> n)</td></tr>
<tr class="memdesc:aaba27b70744d34815776697084245777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the Capacity is at least n.  <a href="#aaba27b70744d34815776697084245777">More...</a><br/></td></tr>
<tr class="separator:aaba27b70744d34815776697084245777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c6d1d7790dda2722f1c9a95ae66d3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a52c6d1d7790dda2722f1c9a95ae66d3b">Resize</a> (<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> n)</td></tr>
<tr class="memdesc:a52c6d1d7790dda2722f1c9a95ae66d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container so that it contains n elements.  <a href="#a52c6d1d7790dda2722f1c9a95ae66d3b">More...</a><br/></td></tr>
<tr class="separator:a52c6d1d7790dda2722f1c9a95ae66d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element Access</div></td></tr>
<tr class="memitem:a5041f2722edbd22fd0bf6d280a78fb2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a5041f2722edbd22fd0bf6d280a78fb2a">At</a> (<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> n) const </td></tr>
<tr class="memdesc:a5041f2722edbd22fd0bf6d280a78fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element in position n in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#a5041f2722edbd22fd0bf6d280a78fb2a">More...</a><br/></td></tr>
<tr class="separator:a5041f2722edbd22fd0bf6d280a78fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d81f325dffc7fdcb4af51987fcae5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a4d81f325dffc7fdcb4af51987fcae5df">operator[]</a> (<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> n) const </td></tr>
<tr class="memdesc:a4d81f325dffc7fdcb4af51987fcae5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element in position n in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#a4d81f325dffc7fdcb4af51987fcae5df">More...</a><br/></td></tr>
<tr class="separator:a4d81f325dffc7fdcb4af51987fcae5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7949f34a5f3b8a427868c92680472691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a7949f34a5f3b8a427868c92680472691">Front</a> () const </td></tr>
<tr class="memdesc:a7949f34a5f3b8a427868c92680472691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#a7949f34a5f3b8a427868c92680472691">More...</a><br/></td></tr>
<tr class="separator:a7949f34a5f3b8a427868c92680472691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53cd964ab723eba0af88dbba630529b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#aa53cd964ab723eba0af88dbba630529b">Back</a> () const </td></tr>
<tr class="memdesc:aa53cd964ab723eba0af88dbba630529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#aa53cd964ab723eba0af88dbba630529b">More...</a><br/></td></tr>
<tr class="separator:aa53cd964ab723eba0af88dbba630529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccea09ed6061842e203a128b1d15d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a4ccea09ed6061842e203a128b1d15d38">AsyncAt</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> n, T *result) const </td></tr>
<tr class="memdesc:a4ccea09ed6061842e203a128b1d15d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element in position n in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#a4ccea09ed6061842e203a128b1d15d38">More...</a><br/></td></tr>
<tr class="separator:a4ccea09ed6061842e203a128b1d15d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr class="memitem:abaa9f4f6a5d0d029b7b09b207a881e01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#abaa9f4f6a5d0d029b7b09b207a881e01">Clear</a> () noexcept</td></tr>
<tr class="memdesc:abaa9f4f6a5d0d029b7b09b207a881e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the elements from the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#abaa9f4f6a5d0d029b7b09b207a881e01">More...</a><br/></td></tr>
<tr class="separator:abaa9f4f6a5d0d029b7b09b207a881e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b843e22db538e31fe5388266bec27b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a4b843e22db538e31fe5388266bec27b7">PushBack</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4b843e22db538e31fe5388266bec27b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element at the end of the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.  <a href="#a4b843e22db538e31fe5388266bec27b7">More...</a><br/></td></tr>
<tr class="separator:a4b843e22db538e31fe5388266bec27b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaff7d0c02745c89349c19ccba6848a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#afcaff7d0c02745c89349c19ccba6848a">InsertAt</a> (<a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, const <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:afcaff7d0c02745c89349c19ccba6848a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value at the specified position.  <a href="#afcaff7d0c02745c89349c19ccba6848a">More...</a><br/></td></tr>
<tr class="separator:afcaff7d0c02745c89349c19ccba6848a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f11691760337b76c49f18db0f10b05"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:af6f11691760337b76c49f18db0f10b05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#af6f11691760337b76c49f18db0f10b05">InsertAt</a> (<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, InputIterator begin, InputIterator end)</td></tr>
<tr class="memdesc:af6f11691760337b76c49f18db0f10b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a sequence of elements starting at the specified position.  <a href="#af6f11691760337b76c49f18db0f10b05">More...</a><br/></td></tr>
<tr class="separator:af6f11691760337b76c49f18db0f10b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e459d60d2e5e226ca8e1071582c23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ae57e459d60d2e5e226ca8e1071582c23">AsyncInsertAt</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, const <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:ae57e459d60d2e5e226ca8e1071582c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value at the specified position asynchronously.  <a href="#ae57e459d60d2e5e226ca8e1071582c23">More...</a><br/></td></tr>
<tr class="separator:ae57e459d60d2e5e226ca8e1071582c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b10512407484abb67858dee56f5a40"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ac1b10512407484abb67858dee56f5a40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ac1b10512407484abb67858dee56f5a40">AsyncInsertAt</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, InputIterator begin, InputIterator end)</td></tr>
<tr class="memdesc:ac1b10512407484abb67858dee56f5a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a sequence of elements starting at the specified position asynchronously.  <a href="#ac1b10512407484abb67858dee56f5a40">More...</a><br/></td></tr>
<tr class="separator:ac1b10512407484abb67858dee56f5a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c0f9b4e66907b236e866e86f438184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a20c0f9b4e66907b236e866e86f438184">BufferedInsertAt</a> (const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> pos, const <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a20c0f9b4e66907b236e866e86f438184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffered Insert method.  <a href="#a20c0f9b4e66907b236e866e86f438184">More...</a><br/></td></tr>
<tr class="separator:a20c0f9b4e66907b236e866e86f438184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b89dc4cb141559dfcfaa3f42bfe56d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a1b89dc4cb141559dfcfaa3f42bfe56d6">BufferedAsyncInsertAt</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> pos, const <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a1b89dc4cb141559dfcfaa3f42bfe56d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous Buffered Insert method.  <a href="#a1b89dc4cb141559dfcfaa3f42bfe56d6">More...</a><br/></td></tr>
<tr class="separator:a1b89dc4cb141559dfcfaa3f42bfe56d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82b288c5e4fe984bbb7093ce2dfde0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ad82b288c5e4fe984bbb7093ce2dfde0d">WaitForBufferedInsert</a> ()</td></tr>
<tr class="memdesc:ad82b288c5e4fe984bbb7093ce2dfde0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize method for buffered insertions.  <a href="#ad82b288c5e4fe984bbb7093ce2dfde0d">More...</a><br/></td></tr>
<tr class="separator:ad82b288c5e4fe984bbb7093ce2dfde0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algorithms</div></td></tr>
<tr class="memitem:a35b98ffc99f64690a55408d847e41cb7"><td class="memTemplParams" colspan="2">template&lt;typename ApplyFunT , typename... Args&gt; </td></tr>
<tr class="memitem:a35b98ffc99f64690a55408d847e41cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a35b98ffc99f64690a55408d847e41cb7">Apply</a> (const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, ApplyFunT &amp;&amp;function, Args &amp;...args)</td></tr>
<tr class="memdesc:a35b98ffc99f64690a55408d847e41cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user-defined function to an element.  <a href="#a35b98ffc99f64690a55408d847e41cb7">More...</a><br/></td></tr>
<tr class="separator:a35b98ffc99f64690a55408d847e41cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6157b35194197e1cf6491bc70cf08e14"><td class="memTemplParams" colspan="2">template&lt;typename ApplyFunT , typename... Args&gt; </td></tr>
<tr class="memitem:a6157b35194197e1cf6491bc70cf08e14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a6157b35194197e1cf6491bc70cf08e14">AsyncApply</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> position, ApplyFunT &amp;&amp;function, Args &amp;...args)</td></tr>
<tr class="memdesc:a6157b35194197e1cf6491bc70cf08e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously applies a user-defined function to an element.  <a href="#a6157b35194197e1cf6491bc70cf08e14">More...</a><br/></td></tr>
<tr class="separator:a6157b35194197e1cf6491bc70cf08e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2d723d26f4ff30dfea4bd77703e475"><td class="memTemplParams" colspan="2">template&lt;typename ApplyFunT , typename... Args&gt; </td></tr>
<tr class="memitem:aea2d723d26f4ff30dfea4bd77703e475"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#aea2d723d26f4ff30dfea4bd77703e475">ForEachInRange</a> (const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> first, const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> last, ApplyFunT &amp;&amp;function, Args &amp;...args)</td></tr>
<tr class="memdesc:aea2d723d26f4ff30dfea4bd77703e475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user-defined function to every element in the specified range.  <a href="#aea2d723d26f4ff30dfea4bd77703e475">More...</a><br/></td></tr>
<tr class="separator:aea2d723d26f4ff30dfea4bd77703e475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab3e99caafbae6cf639744079b9e9cc"><td class="memTemplParams" colspan="2">template&lt;typename ApplyFunT , typename... Args&gt; </td></tr>
<tr class="memitem:a8ab3e99caafbae6cf639744079b9e9cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a8ab3e99caafbae6cf639744079b9e9cc">AsyncForEachInRange</a> (<a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;handle, const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> first, const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> last, ApplyFunT &amp;&amp;function, Args &amp;...args)</td></tr>
<tr class="memdesc:a8ab3e99caafbae6cf639744079b9e9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously applies a user-defined function to every element in the specified range.  <a href="#a8ab3e99caafbae6cf639744079b9e9cc">More...</a><br/></td></tr>
<tr class="separator:a8ab3e99caafbae6cf639744079b9e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classshad_1_1AbstractDataStructure"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classshad_1_1AbstractDataStructure')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classshad_1_1AbstractDataStructure.html">shad::AbstractDataStructure&lt; Vector&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memitem:aaf93dd611be143134360cf0b0570ce81 inherit pub_methods_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#aaf93dd611be143134360cf0b0570ce81">AbstractDataStructure</a> ()=default</td></tr>
<tr class="memdesc:aaf93dd611be143134360cf0b0570ce81 inherit pub_methods_classshad_1_1AbstractDataStructure"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aaf93dd611be143134360cf0b0570ce81">More...</a><br/></td></tr>
<tr class="separator:aaf93dd611be143134360cf0b0570ce81 inherit pub_methods_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a19cf7c81eea1bbf2f1f3222ac6b4a4a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#a19cf7c81eea1bbf2f1f3222ac6b4a4a5">Vector</a> (<a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a> oid, <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> n)</td></tr>
<tr class="separator:a19cf7c81eea1bbf2f1f3222ac6b4a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac9d0ae866fc73cd8c7637ff2691c13bb"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1Vector.html#ac9d0ae866fc73cd8c7637ff2691c13bb">AbstractDataStructure&lt; Vector&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="separator:ac9d0ae866fc73cd8c7637ff2691c13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classshad_1_1AbstractDataStructure"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classshad_1_1AbstractDataStructure')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classshad_1_1AbstractDataStructure.html">shad::AbstractDataStructure&lt; Vector&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memitem:a31b56084146be9afeb69a2b14970aba1 inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classshad_1_1AbstractDataStructure.html#a8bb29450966955c546d40421ce46316f">SharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">Create</a> (Args...args)</td></tr>
<tr class="memdesc:a31b56084146be9afeb69a2b14970aba1 inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create method.  <a href="#a31b56084146be9afeb69a2b14970aba1">More...</a><br/></td></tr>
<tr class="separator:a31b56084146be9afeb69a2b14970aba1 inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161d9fddcb57d50c24f187e0b8e23f66 inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#a161d9fddcb57d50c24f187e0b8e23f66">Destroy</a> (const <a class="el" href="classshad_1_1AbstractDataStructure.html#a8772079d2686692828cfbf342cc2b594">ObjectID</a> &amp;oid)</td></tr>
<tr class="memdesc:a161d9fddcb57d50c24f187e0b8e23f66 inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy method.  <a href="#a161d9fddcb57d50c24f187e0b8e23f66">More...</a><br/></td></tr>
<tr class="separator:a161d9fddcb57d50c24f187e0b8e23f66 inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6262772c3f113c09d4d83bba5aab271b inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classshad_1_1AbstractDataStructure.html#a8bb29450966955c546d40421ce46316f">SharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#a6262772c3f113c09d4d83bba5aab271b">GetPtr</a> (<a class="el" href="classshad_1_1AbstractDataStructure.html#a8772079d2686692828cfbf342cc2b594">ObjectID</a> oid)</td></tr>
<tr class="memdesc:a6262772c3f113c09d4d83bba5aab271b inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataStructure Shared pointer getter.  <a href="#a6262772c3f113c09d4d83bba5aab271b">More...</a><br/></td></tr>
<tr class="separator:a6262772c3f113c09d4d83bba5aab271b inherit pub_static_methods_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classshad_1_1AbstractDataStructure"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classshad_1_1AbstractDataStructure')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classshad_1_1AbstractDataStructure.html">shad::AbstractDataStructure&lt; Vector&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memitem:aad7fd98b646c82cc02a4ea968e11c60e inherit pro_static_methods_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#aad7fd98b646c82cc02a4ea968e11c60e">UpdateCatalogAndConstruct</a> (const <a class="el" href="classshad_1_1AbstractDataStructure.html#a8772079d2686692828cfbf342cc2b594">ObjectID</a> &amp;oid, Args &amp;&amp;...args)</td></tr>
<tr class="separator:aad7fd98b646c82cc02a4ea968e11c60e inherit pro_static_methods_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bb2c090ed3c4a45b24571f62552ac6 inherit pro_static_methods_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#a40bb2c090ed3c4a45b24571f62552ac6">CreateFunInnerWrapper</a> (const std::tuple&lt; Args...&gt; &amp;&amp;tuple, std::index_sequence&lt; is...&gt;)</td></tr>
<tr class="separator:a40bb2c090ed3c4a45b24571f62552ac6 inherit pro_static_methods_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdbfcd38052daa7e1dc7f27a7a0fdf2 inherit pro_static_methods_classshad_1_1AbstractDataStructure"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshad_1_1AbstractDataStructure.html#a7bdbfcd38052daa7e1dc7f27a7a0fdf2">CreateFunWrapper</a> (const std::tuple&lt; Args...&gt; &amp;args)</td></tr>
<tr class="separator:a7bdbfcd38052daa7e1dc7f27a7a0fdf2 inherit pro_static_methods_classshad_1_1AbstractDataStructure"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;<br/>
class shad::Vector&lt; T, Allocator &gt;</h3>

<p>The <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">Vector</a> data Structure. </p>
<p><a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> is a distributed container that can grow dynamically.</p>
<dl class="section warning"><dt>Warning</dt><dd>The contained type must be trivially copiable.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the entries stored in a <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </td></tr>
    <tr><td class="paramname">Allocator</td><td>The allocator to be used. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad950d846edeeed7cc4a9163f9f679624"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#ad950d846edeeed7cc4a9163f9f679624">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the allocator. </p>

</div>
</div>
<a class="anchor" id="ab677e6f62431a450c856e7ffe44efbc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#ab677e6f62431a450c856e7ffe44efbc6">const_iterator</a> =  Iterator&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random access iterator to const <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba" title="The type of the elements stored in the shad::Vector. ">shad::Vector::value_type</a>. </p>

</div>
</div>
<a class="anchor" id="a46e5348988a063d58ed55c76fc94cec1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a46e5348988a063d58ed55c76fc94cec1">difference_type</a> =  typename allocator_type::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signed integral type used the difference between iterators. </p>

</div>
</div>
<a class="anchor" id="aaa71fd41daa1548f8436bc54ef507976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a> =  Iterator&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random access iterator to <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba" title="The type of the elements stored in the shad::Vector. ">shad::Vector::value_type</a>. </p>

</div>
</div>
<a class="anchor" id="a71193856f7dddb5e9fe0128fe5d12448"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a> =  typename <a class="el" href="classshad_1_1AbstractDataStructure.html">AbstractDataStructure</a>&lt;<a class="el" href="classshad_1_1Vector.html">Vector</a>&lt;T, Allocator&gt;&gt;::<a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the unique identifier for the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">Vector</a>. </p>

</div>
</div>
<a class="anchor" id="a1c97f4eb87d738cb4de97e5b3587c397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> =  typename allocator_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned integral type that can represent any non-negative value of difference_type. </p>

</div>
</div>
<a class="anchor" id="adb97b89826617473f44b4bb1dd3308ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the elements stored in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af3505368cf8e3cef009b8d1f894a8e97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::~<a class="el" href="classshad_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="a19cf7c81eea1bbf2f1f3222ac6b4a4a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a>&#160;</td>
          <td class="paramname"><em>oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a35b98ffc99f64690a55408d847e41cb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ApplyFunT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApplyFunT &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a user-defined function to an element. </p>
<p>Applies a user-defined function to the element at the specified position. Typical usage: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fn(<span class="keywordtype">size_t</span>, <span class="keywordtype">size_t</span>&amp; elem, <span class="keywordtype">size_t</span>&amp; aValue) {</div>
<div class="line">  <span class="comment">// ... do something ...</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; kVectorSize; i++) {</div>
<div class="line">  vectorPtr-&gt;Apply(i, fn, aValue);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ApplyFunT</td><td>User-defined function type. The function prototype should be: <div class="fragment"><div class="line">void(<span class="keywordtype">size_t</span>, T&amp;, Args&amp; args);</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramname">...Args</td><td>Types of the function arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The target position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>The function to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The function arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f503abd217734deaa5baafb8142ab45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ApplyFunT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApplyFunT &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6157b35194197e1cf6491bc70cf08e14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ApplyFunT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::AsyncApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApplyFunT &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously applies a user-defined function to an element. </p>
<p>Asynchronously applies a user-defined function to the element at the specified position.</p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fn(<a class="code" href="classshad_1_1rt_1_1Handle.html">shad::rt::Handle</a>&amp;, <span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span>&amp; elem, <span class="keywordtype">size_t</span>&amp; aValue) {</div>
<div class="line">  <span class="comment">// ... do something ...</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line"><a class="code" href="classshad_1_1rt_1_1Handle.html">shad::rt::Handle</a> handle;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; kVectorSize; i++) {</div>
<div class="line">  vectorPtr-&gt;AsyncApply(handle, i, fn, aValue);</div>
<div class="line">}</div>
<div class="line"><a class="code" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a">shad::rt::waitForCompletion</a>(handle);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Asynchronous operations are guaranteed to have completed only after calling the <a class="el" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a" title="Wait for completion of a set of tasks. ">shad::rt::waitForCompletion(rt::Handle &amp;handle)</a> method.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ApplyFunT</td><td>User-defined function type. The function prototype should be: <div class="fragment"><div class="line">void(<a class="code" href="classshad_1_1rt_1_1Handle.html">shad::rt::Handle</a>&amp;, <span class="keywordtype">size_t</span>, T&amp;, Args&amp; args);</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramname">...Args</td><td>Types of the function arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>Reference to the handle to be used to wait for completion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The target position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>The function to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The function arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81e9f5dd9a9f35d59df36c8e7bb334c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ApplyFunT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::AsyncApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApplyFunT &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ccea09ed6061842e203a128b1d15d38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::AsyncAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element in position n in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>
<p>This methods check whether the requested position is within the bounds of the vector. If the position is out of bounds, the method will throw an std::out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>The handle that will be used for the spawned tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The position of an element in the container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The address where to store the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ab3e99caafbae6cf639744079b9e9cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename ApplyFunT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::AsyncForEachInRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApplyFunT &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously applies a user-defined function to every element in the specified range. </p>
<p>Asynchronously applies a user-defined function to all the elements in the specified range of positions.</p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> asyncApplyFun(rt::Handle&amp;, <span class="keywordtype">size_t</span>&amp; elem, <span class="keywordtype">size_t</span>&amp; aValue) {</div>
<div class="line">  <span class="comment">// ... do something ...</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line">rt::Handle handle;</div>
<div class="line">vectorPtr-&gt;AsyncForEachInRange(0, kVectorSize, kVectorSize, aValue);</div>
<div class="line"><span class="comment">// ... do other work ...</span></div>
<div class="line"><a class="code" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a">shad::rt::waitForCompletion</a>(handle);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Asynchronous operations are guaranteed to have completed only after calling the <a class="el" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a" title="Wait for completion of a set of tasks. ">shad::rt::waitForCompletion(rt::Handle &amp;handle)</a> method.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ApplyFunT</td><td>User-defined function type. The function prototype should be: <div class="fragment"><div class="line">void(<a class="code" href="classshad_1_1rt_1_1Handle.html">shad::rt::Handle</a>&amp;, T&amp;, Args&amp; args);</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">...Args</td><td>Types of the function arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>Reference to the handle to be used to wait for completion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first position of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last position of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>The function to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The function arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae57e459d60d2e5e226ca8e1071582c23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::AsyncInsertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value at the specified position asynchronously. </p>
<p>This method overwrite the element at the specified position. When writing one past the last element, the method will grow the container size by one inserting the value at the end.</p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><a class="code" href="classshad_1_1rt_1_1Handle.html">shad::rt::Handle</a> handle;</div>
<div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; kVectorSize; i++) {</div>
<div class="line">  vectorPtr-&gt;AsyncInsertAt(handle, i, i+1);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ... do other work ...</span></div>
<div class="line"><a class="code" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a">shad::rt::waitForCompletion</a>(handle);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The semantic of this method is different from the insert method of the std::vector. The <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> will NOT make room for the newly inserted element and shift all the element by 1 from position to the end for performance reasons.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>The handle that will be used for the spawned tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position where to write the given value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to be written at the specified position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1b10512407484abb67858dee56f5a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::AsyncInsertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a sequence of elements starting at the specified position asynchronously. </p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><a class="code" href="classshad_1_1rt_1_1Handle.html">shad::rt::Handle</a> handle;</div>
<div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line">vectorPtr-&gt;AsyncInsertAt(</div>
<div class="line">  handle, aPosition, std::begin(someSequence), std::end(someSequence));</div>
<div class="line"><span class="comment">// ... do other work ...</span></div>
<div class="line"><a class="code" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a">shad::rt::waitForCompletion</a>(handle);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The semantic of this method is different from the insert method of the std::vector. The <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> <b>will not</b> make room for the newly inserted elements shifting all the element from position to the end for performance reasons.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>The handle that will be used for the spawned tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position where to write the given value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An input iterator to the start of the sequence to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An input iterator to the end of the sequence to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0feab819cbb5f85388a42e9548983479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::AsyncInsertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5041f2722edbd22fd0bf6d280a78fb2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::At </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element in position n in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>
<p>This methods check whether the requested position is within the bounds of the vector. If the position is out of bounds, the method will throw an std::out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The position of an element in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the element in position n. </dd></dl>

</div>
</div>
<a class="anchor" id="aa53cd964ab723eba0af88dbba630529b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the last element in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Calling this method on an empty container causes undefined behavior.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last element in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b89dc4cb141559dfcfaa3f42bfe56d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::BufferedAsyncInsertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1rt_1_1Handle.html">rt::Handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous Buffered Insert method. </p>
<p>Asynchronously inserts an element at the specified position, using aggregation buffers.</p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><a class="code" href="classshad_1_1rt_1_1Handle.html">shad::rt::Handle</a> handle;</div>
<div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; kVectorSize; i++) {</div>
<div class="line">  vectorPtr-&gt;BufferedAsyncInsertAt(handle, i, i+1);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ... do other work ...</span></div>
<div class="line"><a class="code" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a">shad::rt::waitForCompletion</a>(handle);</div>
<div class="line">vectorPtr-&gt;WaitForBufferedInsert();</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>asynchronous buffered insertions are finalized only after calling the <a class="el" href="namespaceshad_1_1rt.html#a6ea1d3672bac3a80032863b6732a0c0a" title="Wait for completion of a set of tasks. ">shad::rt::waitForCompletion(rt::Handle &amp;handle)</a> method <b>and</b> the <a class="el" href="classshad_1_1Vector.html#ad82b288c5e4fe984bbb7093ce2dfde0d" title="Finalize method for buffered insertions. ">WaitForBufferedInsert()</a> method, in this order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>Reference to the handle to be used to wait for completion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The target position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20c0f9b4e66907b236e866e86f438184"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::BufferedInsertAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffered Insert method. </p>
<p>Inserts an element at the specified position, using aggregation buffers.</p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; kVectorSize; i++) {</div>
<div class="line">  vectorPtr-&gt;BufferedInsertAt(handle, i, i+1);</div>
<div class="line">}</div>
<div class="line">vectorPtr-&gt;WaitForBufferedInsert();</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Insertions are finalized only after calling the <a class="el" href="classshad_1_1Vector.html#ad82b288c5e4fe984bbb7093ce2dfde0d" title="Finalize method for buffered insertions. ">WaitForBufferedInsert()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The target position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac34d718c025cee060735b3bced4cf38b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::BufferEntryInsert </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>, <a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acba3d706d24f0b871dc05423692ac592"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the allocated storage capacity. </p>
<p>The capacity of a <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> represent the maximum number of element that the currently allocated storage can hold without the need to expand. Notice that this does not imply a limit on the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">Vector</a> size. In fact, when the current capacity is exhausted and more is needed, the container will expand its capacity allocating more memory.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the currently allocated storage capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="abaa9f4f6a5d0d029b7b09b207a881e01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the elements from the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>
<p>Removes all the elements from the container (destroying them). It leaves the container with a size and a capacity of 0. </p>

</div>
</div>
<a class="anchor" id="ae3eb293e1a9f7b64ca1a77e40caef993"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container Size is 0, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aea2d723d26f4ff30dfea4bd77703e475"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename ApplyFunT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::ForEachInRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApplyFunT &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a user-defined function to every element in the specified range. </p>
<p>Applies a user-defined function to all the elements in the specified range of positions.</p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fn(<span class="keywordtype">size_t</span>&amp; elem, <span class="keywordtype">size_t</span>&amp; aValue) {</div>
<div class="line">  <span class="comment">// ... do something ...</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line">edsPtr-&gt;ForEachInRange(0, kVectorSize, fn, aValue);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ApplyFunT</td><td>User-defined function type. The function prototype should be: <div class="fragment"><div class="line">void(T&amp;, Args&amp; args);</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">...Args</td><td>Types of the function arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first position of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last position of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>The function to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The function arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7949f34a5f3b8a427868c92680472691"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first element in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Calling this method on an empty container causes undefined behavior.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The first element in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1624c9ed8f177f50071cdeff7ccb3c03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html#a71193856f7dddb5e9fe0128fe5d12448">ObjectID</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::GetGlobalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DataStructure identifier getter. </p>
<p>Returns the global object identifier associated to a DataStructure instance.</p>
<dl class="section warning"><dt>Warning</dt><dd>It must be implemented in the inheriting DataStructure. </dd></dl>

<p>Implements <a class="el" href="classshad_1_1AbstractDataStructure.html#a914a6e24eec3a7f5d51d93323d3a39cc">shad::AbstractDataStructure&lt; Vector&lt; T, Allocator &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afcaff7d0c02745c89349c19ccba6848a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::InsertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value at the specified position. </p>
<p>This method overwrite the element at the specified position.</p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; kVectorSize; i++) {</div>
<div class="line">  vectorPtr-&gt;InsertAt(i, i+1);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The semantic of this method is different from the insert method of the std::vector. The <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> will overwrite the element at poisition.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position where to write the given value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to be written at the specified position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted value. </dd></dl>

</div>
</div>
<a class="anchor" id="af6f11691760337b76c49f18db0f10b05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::InsertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a sequence of elements starting at the specified position. </p>
<p>Typical usage: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vectorPtr = <a class="code" href="classshad_1_1AbstractDataStructure.html#a31b56084146be9afeb69a2b14970aba1">shad::Vector&lt;size_t&gt;::Create</a>(kVectorSize);</div>
<div class="line">vectorPtr-&gt;InsertAt(</div>
<div class="line">  aPosition, std::begin(someSequence), std::end(someSequence));</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The semantic of this method is different from the insert method of the std::vector. The <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> <b>will not</b> make room for the newly inserted elements shifting all the element from position to the end for performance reasons.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position where to write the given value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position where to write the given value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An input iterator to the start of the sequence to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An input iterator to the end of the sequence to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first inserted value. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b3e4b374c0cdc673273716d08c83161"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt;T, Allocator&gt;::<a class="el" href="classshad_1_1Vector.html#aaa71fd41daa1548f8436bc54ef507976">iterator</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::InsertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abf3456999188ff7f9e43ca8d1e7d4bff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::MaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements that <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> can hold. </p>
<p>This methods returns the maximum potential size of the container. However, there is no guarantee that a <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a> will be able to reach that size (i.e., the system might fail to allocate memory before that size is reached). </p>

</div>
</div>
<a class="anchor" id="a4d81f325dffc7fdcb4af51987fcae5df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#adb97b89826617473f44b4bb1dd3308ba">value_type</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element in position n in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>
<p>This methods is similar to At but it is not bound checked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The position of an element in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the element in position n. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b843e22db538e31fe5388266bec27b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::PushBack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element at the end of the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>

</div>
</div>
<a class="anchor" id="aaba27b70744d34815776697084245777"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request that the Capacity is at least n. </p>
<p>Request that the Capacity is enough to store n elements. If n is greater than the current Capacity, the function will cause the container to expand increasing its Capacity to n. In all the other cases, the function does not affect the Capacity of the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Reserve is not thread safe, so don't try to reserve from multiple concurrent tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The requested minimum Capacity for the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52c6d1d7790dda2722f1c9a95ae66d3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the container so that it contains n elements. </p>
<p>Resize the container so that it contains n elements. If n is smaller than the container Size, the content is reduced to the first n elements. If n is greater than the current Size, the container is expanded by inserting at the end as many elements as needed to reach a size of n.</p>
<p>If n is greater than the current capacity, more data blocks will be allocated to extend the capacity to at least n elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The new container size, expressend in number of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc82ec6a8baf31c7b33cfde87309fffe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt;::<a class="el" href="classshad_1_1Vector.html#a1c97f4eb87d738cb4de97e5b3587c397">size_type</a> <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of element stored in the <a class="el" href="classshad_1_1Vector.html" title="The Vector data Structure. ">shad::Vector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of element in the container. </dd></dl>

</div>
</div>
<a class="anchor" id="ad82b288c5e4fe984bbb7093ce2dfde0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshad_1_1Vector.html">shad::Vector</a>&lt; T, Allocator &gt;::WaitForBufferedInsert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize method for buffered insertions. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ac9d0ae866fc73cd8c7637ff2691c13bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classshad_1_1AbstractDataStructure.html">AbstractDataStructure</a>&lt; <a class="el" href="classshad_1_1Vector.html">Vector</a>&lt; T, Allocator &gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/shad/data_structures/<a class="el" href="vector_8h_source.html">vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
